一、配置：
1、save 开启SNAPSHOT
2、appendonly yes，everysec
3、requirepass 123

二、单实例测试：
1、不断增加线程（线程池上线200，模拟tomcat），查询数据（10条），查看性能
（1）设置合理的线程数目：200个模拟tomcat，无限的队列长度
（2）查询响应时间越来越大，200以上，会偶然出现获取不到连接或者查询数量不对的错误.2000ms趋于平稳。
纵向对比：随着数目增加对比（max队列，200核心，abort policy）
线程数=1;总耗时=522;平均=522;核心线程数目=200;查询失败数目=0
线程数=10;总耗时=7471;平均=747;核心线程数目=200;查询失败数目=0
线程数=50;总耗时=119743;平均=2394;核心线程数目=200;查询失败数目=0
线程数=100;总耗时=352670;平均=3526;核心线程数目=200;查询失败数目=0
线程数=200;总耗时=1447559;平均=7237;核心线程数目=200;查询失败数目=20
线程数=500;总耗时=1786953;平均=3573;核心线程数目=200;查询失败数目=0
线程数=1000;总耗时=3210635;平均=3210;核心线程数目=200;查询失败数目=0
线程数=5000;总耗时=11722216;平均=2344;核心线程数目=200;查询失败数目=0
线程数=10000;总耗时=21847232;平均=2184;核心线程数目=200;查询失败数目=0
线程数=50000;总耗时=114207382;平均=2284;核心线程数目=200;查询失败数目=21
线程数=60000;总耗时=168938221;平均=2815;核心线程数目=200;查询失败数目=57
线程数=100000;总耗时=215409854;平均=2154;核心线程数目=200;查询失败数目=116
线程数=200000;总耗时=434185331;平均=2170;核心线程数目=200;查询失败数目=121
线程数=400000;总耗时=855191783;平均=2137;核心线程数目=200;查询失败数目=301
线程数=600000;总耗时=1204651186;平均=2007;核心线程数目=200;查询失败数目=32888
线程数=800000;总耗时=1701296501;平均=2126;核心线程数目=200;查询失败数目=569
线程数=1000000;总耗时=2065944398;平均=2065;核心线程数目=200;查询失败数目=33764
线程数=1500000;总耗时=708606733;平均=472;核心线程数目=200;查询失败数目=1171399

现象：Redis的查询一直在2000左右，随着并发数越多，失败数目越大。
（1）Redis查询速度超过2000ms，主要瓶颈并不是redis，而是线程池（模拟tomcat）最大线程数是200，需要一直排队，并且电脑cpu不足。
（2）查询失败：第一，获取不到jedis连接，Cannot get Jedis connection; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool
               第二，查询的数目不对，也就是没有从redis查到正确数目的数据。Retry3次，可以解决该问题，具体生产环境可以retry，也可以不retry，取决于业务。
	Jedis连接获取不到解决方案：
	
2、Redis-benchMark测试Redis本身性能：

3、测试高并发修改库存

4、中断服务、查看丢失数据&以及备份数据
（1）设置SANPSHOT和AOP同时生效，aof everysecc && save 默认


三、在电商项目中应用：
1、列表页：销量zset（100 expire 5min），发布时间zset（100 expire 10min），类别商品set（全量 expire 15min），品牌商品Set（全量 expire 20min），查询的时候可以组合求交集(expire 1min)
2、商品信息Hash（expire 1h）
3、商品库存&销量Hash(no expire)
3、修改库存&销量：统一库存接口，下单之后修改Redis，发送消息至MQ修改Mysql；
缓存校正工具：定期校正缓存和mysql的不一致
4、分布式锁：库存修改需要用到分布式锁

四、缓存策略：
1、初始化所有缓存，设置expire
2、更新缓存采用淘汰策略
3、缓存雪崩：集中失效；随机增加过期时间；（过期时间尽量不要设置一样的）
6、缓存穿透：查询一定不存在的数据；暂时不解决；
7、缓存初始化工具：初始化mysql数据到redis

五、秒杀场景防止超卖：
